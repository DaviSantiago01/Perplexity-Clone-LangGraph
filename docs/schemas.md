# üìã schemas.py - Documenta√ß√£o T√©cnica

## Vis√£o Geral

O arquivo `schemas.py` define as **estruturas de dados** fundamentais do sistema usando **Pydantic**. Estes modelos garantem valida√ß√£o de tipos, serializa√ß√£o consistente e documenta√ß√£o autom√°tica dos dados que fluem atrav√©s do workflow LangGraph.

**üöÄ Atualiza√ß√£o**: Schemas otimizados para integra√ß√£o com Groq LLMs e c√≥digo completamente documentado com coment√°rios detalhados.

## üéØ Prop√≥sito dos Schemas

### Por que usar Pydantic?

1. **Valida√ß√£o Autom√°tica**: Garante que dados estejam no formato correto
2. **Type Safety**: Previne erros de tipo em tempo de execu√ß√£o
3. **Serializa√ß√£o**: Convers√£o autom√°tica para JSON/dict
4. **Documenta√ß√£o**: Auto-documenta√ß√£o dos modelos
5. **IDE Support**: Melhor autocomplete e detec√ß√£o de erros

## üìä Modelos Definidos

### 1. `QueryResult`

```python
class QueryResult(BaseModel):
    title: str
    url: str
    summary: str
```

#### Prop√≥sito
Representa o **resultado de uma pesquisa individual** ap√≥s processamento pelo n√≥ `single_search`.

#### Campos Detalhados

| Campo | Tipo | Descri√ß√£o | Exemplo |
|-------|------|-----------|----------|
| `title` | `str` | T√≠tulo da p√°gina/artigo encontrado | "Intelig√™ncia Artificial - Wikipedia" |
| `url` | `str` | URL completa da fonte | "https://pt.wikipedia.org/wiki/Intelig√™ncia_artificial" |
| `summary` | `str` | Resumo gerado pelo LLM do conte√∫do | "IA √© a capacidade de m√°quinas simularem..." |

#### Fluxo de Cria√ß√£o

```python
# No n√≥ single_search
results = tavily_client.search(query, max_results=1)

for result in results:
    # Extra√ß√£o de dados brutos
    title = result.get('title', 'Sem t√≠tulo')
    url = result.get('url', 'Sem URL')
    content = result.get('content', 'Sem conte√∫do')
    
    # Processamento via LLM Groq (ultrarr√°pido)
    summary_response = llm.invoke(resume_prompt + content)
    summary = summary_response.content
    
    # Cria√ß√£o do objeto validado
    query_result = QueryResult(
        title=title,
        url=url,
        summary=summary
    )
```

#### Valida√ß√µes Autom√°ticas

- **title**: Deve ser string n√£o-vazia
- **url**: Deve ser string (valida√ß√£o de URL pode ser adicionada)
- **summary**: Deve ser string n√£o-vazia

#### Uso no Sistema

1. **Cria√ß√£o**: No n√≥ `single_search` ap√≥s processar resultado Tavily
2. **Armazenamento**: Adicionado √† lista `query_results` no estado
3. **Consumo**: Usado no n√≥ `final_write` para gerar resposta final

### 2. `ReportState`

```python
class ReportState(TypedDict):
    user_input: str
    final_response: str
    queries: List[str]
    query_results: List[QueryResult]
```

#### Prop√≥sito
Define o **estado compartilhado** que flui atrav√©s de todos os n√≥s do LangGraph. √â o "c√©rebro" que mant√©m todas as informa√ß√µes durante o processamento.

#### Campos Detalhados

| Campo | Tipo | Descri√ß√£o | Momento de Cria√ß√£o |
|-------|------|-----------|--------------------|
| `user_input` | `str` | Pergunta original do usu√°rio | In√≠cio do workflow |
| `final_response` | `str` | Resposta final compilada | N√≥ `final_write` |
| `queries` | `List[str]` | Lista de queries de pesquisa | N√≥ `build_first_queries` |
| `query_results` | `List[QueryResult]` | Resultados processados | N√≥s `single_search` |

#### Evolu√ß√£o do Estado

```python
# Estado inicial
state = {
    "user_input": "Como funciona a intelig√™ncia artificial?",
    "final_response": "",
    "queries": [],
    "query_results": []
}

# Ap√≥s build_first_queries
state = {
    "user_input": "Como funciona a intelig√™ncia artificial?",
    "final_response": "",
    "queries": [
        "defini√ß√£o intelig√™ncia artificial",
        "algoritmos machine learning",
        "aplica√ß√µes pr√°ticas IA"
    ],
    "query_results": []
}

# Ap√≥s single_search (executado 3x em paralelo)
state = {
    "user_input": "Como funciona a intelig√™ncia artificial?",
    "final_response": "",
    "queries": [...],
    "query_results": [
        QueryResult(title="IA - Wikipedia", url="...", summary="..."),
        QueryResult(title="ML Algorithms", url="...", summary="..."),
        QueryResult(title="AI Applications", url="...", summary="...")
    ]
}

# Ap√≥s final_write
state = {
    "user_input": "Como funciona a intelig√™ncia artificial?",
    "final_response": "A intelig√™ncia artificial √©...",
    "queries": [...],
    "query_results": [...]
}
```

## üîÑ Integra√ß√£o com LangGraph

### TypedDict vs BaseModel

**Por que `ReportState` usa `TypedDict`?**

- **LangGraph Requirement**: LangGraph espera `TypedDict` para estados
- **Performance**: Mais leve que classes Pydantic
- **Flexibilidade**: Permite modifica√ß√µes din√¢micas

**Por que `QueryResult` usa `BaseModel`?**

- **Valida√ß√£o**: Dados externos (Tavily) precisam de valida√ß√£o
- **M√©todos**: Acesso a m√©todos Pydantic (`.dict()`, `.json()`)
- **Serializa√ß√£o**: F√°cil convers√£o para diferentes formatos

### Fluxo de Dados

```mermaid
graph TD
    A[user_input: str] --> B[build_first_queries]
    B --> C[queries: List[str]]
    C --> D[single_search]
    D --> E[QueryResult objects]
    E --> F[query_results: List[QueryResult]]
    F --> G[final_write]
    G --> H[final_response: str]
```

## üõ°Ô∏è Valida√ß√£o e Tratamento de Erros

### Valida√ß√£o Autom√°tica

```python
# Exemplo de valida√ß√£o autom√°tica
try:
    result = QueryResult(
        title="",  # String vazia - pode causar problemas
        url="invalid-url",  # URL inv√°lida
        summary=None  # Tipo incorreto
    )
except ValidationError as e:
    print(f"Erro de valida√ß√£o: {e}")
```

### Tratamento de Dados Ausentes

```python
# No single_search - tratamento defensivo
title = result.get('title', 'Sem t√≠tulo')
url = result.get('url', 'Sem URL')
content = result.get('content', 'Sem conte√∫do')

# Valida√ß√£o adicional
if not content or content == 'Sem conte√∫do':
    summary = "Conte√∫do n√£o dispon√≠vel para resumo"
else:
    summary_response = llm.invoke(resume_prompt + content)
    summary = summary_response.content or "Resumo n√£o gerado"
```

## üîß Extens√µes e Melhorias

### Valida√ß√µes Customizadas

```python
from pydantic import validator, HttpUrl
from typing import Optional

class QueryResult(BaseModel):
    title: str
    url: HttpUrl  # Valida√ß√£o autom√°tica de URL
    summary: str
    confidence: Optional[float] = None  # Score de confian√ßa
    
    @validator('title')
    def title_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('T√≠tulo n√£o pode estar vazio')
        return v.strip()
    
    @validator('summary')
    def summary_min_length(cls, v):
        if len(v) < 10:
            raise ValueError('Resumo deve ter pelo menos 10 caracteres')
        return v
    
    @validator('confidence')
    def confidence_range(cls, v):
        if v is not None and (v < 0 or v > 1):
            raise ValueError('Confian√ßa deve estar entre 0 e 1')
        return v
```

### Campos Adicionais

```python
from datetime import datetime
from enum import Enum

class SourceType(str, Enum):
    ACADEMIC = "academic"
    NEWS = "news"
    BLOG = "blog"
    WIKI = "wiki"
    OTHER = "other"

class EnhancedQueryResult(BaseModel):
    title: str
    url: HttpUrl
    summary: str
    source_type: SourceType
    relevance_score: float
    extracted_at: datetime = datetime.now()
    word_count: int
    language: str = "pt"
    
    class Config:
        use_enum_values = True  # Serializa enums como valores
```

### Estado Estendido

```python
from typing import Optional, Dict, Any

class ExtendedReportState(TypedDict):
    # Campos originais
    user_input: str
    final_response: str
    queries: List[str]
    query_results: List[QueryResult]
    
    # Campos adicionais
    session_id: Optional[str]
    processing_time: Optional[float]
    error_messages: List[str]
    metadata: Dict[str, Any]
    language: str
    search_depth: int
```

## üìä Serializa√ß√£o e Persist√™ncia

### Convers√£o para JSON

```python
# QueryResult para JSON
result = QueryResult(
    title="Exemplo",
    url="https://example.com",
    summary="Resumo do exemplo"
)

# Serializa√ß√£o
json_data = result.json()
dict_data = result.dict()

# Deserializa√ß√£o
result_from_json = QueryResult.parse_raw(json_data)
result_from_dict = QueryResult(**dict_data)
```

### Salvamento de Estado

```python
import json
from typing import List

def save_state(state: ReportState, filename: str):
    """Salva estado em arquivo JSON"""
    # Converter QueryResult objects para dicts
    serializable_state = {
        "user_input": state["user_input"],
        "final_response": state["final_response"],
        "queries": state["queries"],
        "query_results": [result.dict() for result in state["query_results"]]
    }
    
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(serializable_state, f, ensure_ascii=False, indent=2)

def load_state(filename: str) -> ReportState:
    """Carrega estado de arquivo JSON"""
    with open(filename, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Reconstruir QueryResult objects
    query_results = [QueryResult(**result) for result in data["query_results"]]
    
    return ReportState(
        user_input=data["user_input"],
        final_response=data["final_response"],
        queries=data["queries"],
        query_results=query_results
    )
```

## üß™ Testes e Valida√ß√£o

### Testes Unit√°rios

```python
import pytest
from pydantic import ValidationError

def test_query_result_creation():
    """Testa cria√ß√£o v√°lida de QueryResult"""
    result = QueryResult(
        title="Teste",
        url="https://example.com",
        summary="Resumo de teste"
    )
    assert result.title == "Teste"
    assert str(result.url) == "https://example.com"
    assert result.summary == "Resumo de teste"

def test_query_result_validation():
    """Testa valida√ß√£o de dados inv√°lidos"""
    with pytest.raises(ValidationError):
        QueryResult(
            title="",  # T√≠tulo vazio
            url="invalid-url",  # URL inv√°lida
            summary=""  # Resumo vazio
        )

def test_state_evolution():
    """Testa evolu√ß√£o do estado"""
    state = ReportState(
        user_input="Teste",
        final_response="",
        queries=[],
        query_results=[]
    )
    
    # Adicionar queries
    state["queries"] = ["query1", "query2"]
    assert len(state["queries"]) == 2
    
    # Adicionar resultados
    result = QueryResult(title="T", url="https://ex.com", summary="S")
    state["query_results"].append(result)
    assert len(state["query_results"]) == 1
```

## üìà Performance e Otimiza√ß√£o

### Uso de Mem√≥ria (com Groq)

- **QueryResult**: ~200-500 bytes por objeto
- **ReportState**: ~1-5KB dependendo do n√∫mero de resultados
- **Serializa√ß√£o**: JSON compacto para persist√™ncia
- **Vantagem Groq**: Sem overhead de modelos locais, menor uso de RAM

### Otimiza√ß√µes

```python
# Usar __slots__ para reduzir uso de mem√≥ria
class OptimizedQueryResult(BaseModel):
    title: str
    url: str
    summary: str
    
    class Config:
        # Otimiza√ß√µes Pydantic
        allow_reuse=True
        validate_assignment=False  # Desabilita valida√ß√£o em atribui√ß√µes
        copy_on_model_validation=False  # Evita c√≥pias desnecess√°rias
```

Os schemas definidos neste arquivo s√£o fundamentais para manter a integridade e consist√™ncia dos dados em todo o sistema, proporcionando uma base s√≥lida para o workflow complexo do LangGraph.